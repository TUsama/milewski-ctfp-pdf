% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{范}{畴}，其实是一个简单得不能再简单的概念。
一个范畴乃是由两部分组成：\newterm{对象}，以及连接对象之间的\newterm{箭头}。画图
出来就更简单了，不是吗？一个对象可以用一个圆或是一个点来表示，箭头则
没有什么花俏写法，就是箭头。（我有时也会将对象画成小猪，
箭头画成烟花，增加点童趣）。
但范畴的本质实际上是\emph{复合}。反过来说也是如此，复合的本质实际上是
范畴。箭头就是那个用来表示复合的符号。
所以，如果你看到在对象$A$与对象$B$之间有一根箭头，而对象$B$和对象$C$之间也有箭头，
那么不用怀疑，$A$与$C$之间也有箭头。


\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{images/img_1330.jpg}
  \caption{在范畴中，如果有一根箭头从$A$指向$B$，又有一根箭头从$B$指向$C$
，那么$A$和$C$之间也会有箭头，亦即，它们之间也有复合关系。注意，此图解不是完整版，因为它们还缺少恒等态射（Identity Morphism）。}

\end{figure}

\section{箭头即是函数}

概念太多，已经晕了？别急。下面我们就会讨论些更实际的东西。
首先是箭头，我们也可以叫它为“函数”，在范畴论中，
它叫做\newterm{态射}。相当于你现在有一个$f$函数，它接收$A$类型的参数，并返回
$B$。又有另外一个函数$g$，接收$B$并返回$C$。
你可以将它们俩复合在一起，只需将$f$的返回值传入到$g$中即可。这样，你就定义了一个新的函数，它接收
$A$并返回$C$。

在数学中，这样的复合关系可以用一个小圆圈来表示：
$g \circ f$。需要注意的是，复合的顺序是从右到左。有些人可能会在这上面栽跟头。
你可能想起 Unix 中的管道标记，
例如：

\begin{snip}{text}
lsof | grep Chrome
\end{snip}
或是在 F\# 中的那个 V 型符号\code{>>}，它们的顺序
都是从左到右。但在数学 Haskell 中，函数的复合始终是从右到左。
或许你可以把$g \circ f$读成“g\emph{ 后应用于（After）}f”

如果你还是不甚理解，你可以阅读一下下面的 C 代码。现在定义一个
函数 \code{f}，它接收 \code{A} 类型的参数，并返回 
\code{B} 类型的值。

\begin{snip}{text}
B f(A a);
\end{snip}
再定义一个函数，如下：

\begin{snip}{text}
C g(B b);
\end{snip}
它们的复合便是：

\begin{snip}{text}
C g_after_f(A a)
{
    return g(f(a));
}
\end{snip}
观察 return 代码块，你会发现复合的顺序确实是从右
到左：\code{g(f(a))}。

可惜的是，C++ 标准库内并没有一个能够返回两个函数的复合的模板，
若是有我也不必多费口舌。
我们也可以用 Haskell 来写一遍，换换口味。下面是函数 A 和 B 的声明：


\src{snippet01}
类似地：

\src{snippet02}
它们的复合便是：

\src{snippet03}
你可以看到，在 Haskell 中书写函数复合是如此的方便直接。
反观 C++，实在是显得有些又臭又长。不仅如此，Haskell 甚至能够
使用 Unicode 字符来书写复合：

% don't 'mathify' this block
\begin{snip}{text}
g ◦ f
\end{snip}

还能用 Unicode 中的双冒号以及箭头：
% don't 'mathify' this block
\begin{snipv}
f \ensuremath{\Colon} A → B
\end{snipv}
这是我们的 Haskell 课堂的第一个知识点：双冒号意味着“它的类型是\ldots{}”
函数的类型指的在两个类型之间插入一个箭头而形成的整体。
若要求两个函数的复合，
只需在两个函数间插入一个英文句号（或是 Unicode 圆圈）即可。

\section{复合的性质}

复合有两个极为重要的性质，任何范畴的复合都必须遵从
这两个性质。

\begin{enumerate}
  \item
        复合有结合性质。给定三个态射$f$$g$以及$h$，
        并且三者可复合在一起（也就是说，前一函数的输出是后一函数的输入），
        那么你无需用括号来指定复合的顺序。如果使用数学语言来表示，
        可以写为：
        \[h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f\]
        若用 Haskell 来表示，则为（伪代码）：

        \src{snippet04}[b]
        （之所以说是“伪代码”，是因为函数间没有相等性这一概念）

        如果我们面对的是函数，那么结合律是很容易看出的，
        但若是面对其他的范畴，则可能会让人有些迟疑。

  \item
        对于每个对象$A$，它都有一个指向自己的、
        作为复合的单位（Unit）的箭头。何为复合的单位？
        复合的单位指的是，任何一个从$A$出发的，
        或是结束于$A$的箭头，在于这一单位结合时，都会返回自身。对象 A 的单位箭头
        被称为$\idarrow[A]$（$A$的\newterm{恒等性}）下面用数学语言表述一遍：
        假设$f$为一个从$A$出发，结束于$B$的复合，则有：
        \[f \circ \idarrow[A] = f\]
        与
        \[\idarrow[B] \circ f = f\]
\end{enumerate}
如果我们把这一概念套到函数上，那么在函数中，恒等性实际上
指的就是恒等函数，也就是将传入参数直接返回的函数。恒等函数
对所有的类型一视同仁，没有类型的限制。也就是说，恒等函数是通用多态（Universally Polymorphic）的。
在 C++ 中，我们可以定义如下的模板：

\begin{snip}{cpp}
template<class T> T id(T x) { return x; }
\end{snip}
当然，具体实现没那么简单，因为你不仅得考虑传入的东西，
还得考虑传入的方式（不仅得考虑值，还得考虑引用、不可变引用
以及 move 函数之类的）。

在 Haskell 中，恒等函数直接被包含在了标准库中
（库名字为 Prelude）。以下是函数的声明以及定义：

\src{snippet05}
可以看到，在 Haskell 中，实现一个多态函数易如反掌。在声明当中，
你仅需将类型替换为类型变量即可。注意，此处有个小细节：确切类型的名字是以
大写字母打头的，而类型变量则为小写打头。
所以此处的
 \code{a} 指的是任意类型。

一个 Haskell 函数由若干部分内容构成，一个是函数的名称， 
二个是跟在函数名称后的形式参数。此处的形参只有一个，也就是\code{X}。函数体则是在
等号的后面。如此的简洁扼要是不是让你
难以置信？但很快你就会发现，这套语法实在是恰如其分。在函数式编程中，主要的写法就是定义函数以及调用函数，
所以关于此二者的语法统统被精炼到了近乎缩无可缩的地步。
不仅参数列表不需要括号括起来，参数之间
也不需要用逗号分隔开（学到下面的多参数函数的定义时你就懂了）。



函数体只能是一个表达式，与陈述（Statement）
没有丝毫关系。函数的结果就是该表达式，此处指的就是 
\code{X}。

以上种种便是我们 Haskell 第二课的内容。

若是用 Haskell 伪代码来表示恒等条件，可为：

\src{snippet06}
你可能会对犯嘀咕：为什么老是在恒等函数上
打转？这玩意有什么用？这是个好问题，我们可以对数字 0 也
发出同样的疑问。0 作为一个符号，意味着空无一物。古罗马的数字系统里没有 0，但他们一样能建造出
优秀的道路与沟渠，有些建筑成果甚至保留到了今天。


像是 0 以及 $\id$ 这样的中值，会在我们使用符号变量时
起到很大的作用。从这方面看，或许能解释为何罗马人在代数上
与阿拉伯与波斯人相差甚远——因为后两者对“0”这一概念颇为熟稔。
恒等函数与 0 有异曲同工之妙。在我们讨论高阶函数时，恒等函数
也会发挥很大的作用，例如作为高阶函数的入参或是返回值。而高阶函数
是我们从符号层面操纵函数的抓手，就像是代数之于数学那样。


总结一下上述的知识点：一个范畴是由若干对象以及箭头（态射）组成的。
箭头之间可以相互复合，并且复合满足结合律。每个对象
都有一个恒等箭头，恒等箭头为复合中的单位元素。

\section{复合乃是编程的本质}

函数式编程的程序员解决问题的方式往往异于寻常。他们会从一些颇有哲学意味的
问题处出发，进而寻找解决方案。例如，在设计一套交互程序时，他们会发问：
什么是交互？而在使用代码实现康威生命游戏时，
他们可能会思考生命的意义这类问题。
由此出发，我也提出一个疑问：什么是编程？
若是从计算机底层角度来回答，我们可以说，编程就是在告诉电脑
该去做什么。“将内存地址 X 处的内容取出，并将其加入到寄存器 EAX 的
内容中”但实际上，哪怕我们用的是汇编来编程，我们输入的指令也
会比我这儿列出的例子要复杂得多。
我们面对的问题从来都是要比
这里的“搬砖”游戏要复杂得多，否则我们就没必要用电脑了。那我们是如何解决
问题的呢？一般来说，如果问题比较复杂，我们会尝试将问题切割为更小的问题。如果小问题
还是比较复杂，那就继续切，切到能解决为止。
最终，所有的小问题都可以被我们的代码轻松解决。这就是编程的本质：
我们将一块块解决小问题的代码组合在一起，组合出的代码就可以解决大问题。
当然，我们得确保切分出来的小问题能够组合回大问题，
否则拆分就没意义了。

这种层层切割、段段拼接的解决方法并不是计算机强加给我们的。
这实际上是人类心智能力的限制。
我们的大脑只能同一时间处理少量概念。
在心理学中有一篇被广泛引用的论文，
\urlref{http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two}{The
  Magical Number Seven, Plus or Minus Two}，其中提到了一个假说：人类只能记忆 $7 \pm 2$ 个
信息“组块”。随着相关研究的逐渐深入，可能上述关于短期记忆的结论已经过时了。
但我们可以肯定的是，人类的短期记忆确有极限。
比如，在面对一坨千头万绪的代码时，我们时常会感觉到力不从心。
我们追求代码结构的优雅，不是出于视觉的考虑，
而是因为我们的大脑在处理这种结构的信息时更有效率。
当我们使用诸如“优雅”“优美”等词来描述某些代码块时，
我们实际上是在说，这些代码块非常适合用人脑来处理。
若是用上面提到的概念来解释，我们可以说，优雅的代码包含了
数量不多且大小合适的信息组块，我们的心智系统“吃”起来尤为顺心。



那么在我们编程的复合过程中，什么样的组块算作是合适呢？我们可以用一个比喻来说明：组块的表面积
增长速度应该低于它的体积增长速度。（这个比喻很符合直觉，
因为几何物体表面积的增长速度是其大小的平方，而体积的增长速度
是其大小的立方。）
这里的表面积指的就是我们
将组块放入复合中所需要的的信息，而体积指的就是我们实现此组块所需要的的信息，
这里的关键在于，一旦这一组块实现了，我们就可以
把它的实现细节抛到一边，专心于它与其他组块的交互。
在面向对象编程的语言中，表面积中的“表”指的就是类中的对象，
或是类的抽象接口。
而在函数式编程中，它就是函数的声明
（这里我省略掉了一些细节，
但大体上是这样）。

范畴论始终不鼓励我们探寻对象内部。
在范畴论中，一个对象就好似一团抽象的星云。
你对它的了解仅限于它与其他对象的关系，也就是那一根根箭头。
这也是网络搜索引擎为网站排名的策略：分析进出该网站的链接，
而非关注此网站内部（除非弄虚作假）。
在面向对象编程中，
一个理想的对象应该仅暴露它的抽象接口（也就是只有表面，没有体积），
而对象内的方法则扮演了根根箭头。如果你一上来就不得不深挖对象的实现细节，否则
根本无法搞懂该对象如何与其他对象复合在一起，那么，
你便与该编程范式的优越之处失之交臂。


\section{练手时间到}

\begin{enumerate}
  \tightlist
  \item
        用你最喜欢的编程语言实现一个恒等函数，
        尽可能写好。
        （如果你第一喜欢的语言是 Haskell，那就用第二喜欢的）
  \item
        使用你最喜欢的语言实现函数的复合。也就是一个接收两个函数作为参数，
        并且返回它们的复合
        的函数。
  \item
        书写一段程序，检查你写的
        复合函数是否支持恒等函数。
  \item
        互联网是范畴吗？链接是态射吗？
  \item
        Facebook 是范畴吗？
        其中的人们是对象吗？他们之间的友谊是态射吗？
  \item
        一个有向图，在什么情况下是一个范畴？
\end{enumerate}